基础框架(ioc/基础事务/)
### 项目结构
aggregation
  - adater
    - in
        - httpapi  
        - websocket
        - mqconsumer
    - out 
        - mqproducer
        - mysql
        - repositoryImpl
        - redis
        - queryService
        - queryServiceImpl
        - config
        - eventbusimpl
  - application
    - command
      - cmdservice
      - dto
    - query
      - querysvc
      - ->querydto/ resultdto->
    - factory
  - domain
    - root/entity/valueobject
    - repository
    - domainService
    - event （ID，type,status?,time，data）
    - eventbus ? 这个interface放哪一层呢
  - pkg  （可独立出来的包）
    - eventbus 抽象eventbus
  
  mq调用handler 同步 读库的操作还没想好怎么实现 先不管
  可靠消息最终一致性 依赖于事务消息   首先消息的存取都是事务的  回滚则要补偿（反操作）

### DDD项目规范 
api
 在api层本身定义自身路由，然后httphandler构造的时候会去register路由
out
  repoimpl 实现的是领域层定义的接口，然后再注入db做具体操作
  queryimpl 实现的是application.query层的接口， 可以注入多种数据源， redis es db 等做具体查询操作
  eventHandler 监听commandservice发出的领域事件处理   通过 eventbus.dispture(eventhandler) 实现 ，  其中eventhandler会绑定一个事件 event 这样就实现 eventhandler处理event
application  这里将service拆成 query和command
  command  
     实现cqrs command无返回值(错误不算返回值), 
     这里可以注入writedb.tx事务操作 从Load到Save 做事务操作 也可以引入eventbus.send(event) 这里主要是做调度功能各个领域功能。不做具体业务操作逻辑  event（这里应该也可以引入领域事件）
     如果这里有通过调用其他服务的场景，如果是通过 http/grpc框架 能够返回一个 bizerror，可以通过这个bizerror 判断是否回滚
     如果是通过消息队列发送的话，如果有事务一执行的需求，可以使用补偿操作。 这里就不打算引入分布式事务框架了
  query 只定义了 qeuryservice的接口和 query_dto,query result, 由 queryimpl实现对应的操作逻辑
config 理论上可以移动到out/config
domain
  entity/聚合根  不要成为一个贫血模型哦 把业务操作写在这 让后通用command调度
  repo 仓储定义
  error 错误定义
  domainservice 领域服务 需要多个当前领域对象用的 无法用domain单独描述的才写到这， 这个类极少用到
  event定义 定义了领域事件



聚合根和实体的区别 聚合根有独立生命周期 实体的生命周期从属于聚合根的生命， 也就是说 只有聚合根有Load功能。如
一个DDD案例
在产品**销售**场景 有 **Product** 
在秒杀场景中 也有**Product** 
如果 Product这个模型只能在当前上下文使用  这就是限界上下文  上下文可以理解成场景。

（上下文可以有交集吗？）
领域 子域 限界上下文 战略设计

实体 值对象 聚合 工厂 repo 领域服务 领域事件 战术设计

什么是领域
比如 我们是  智能识别定制衣服销售成品的领域 （业务范围  定制，智能识别，销售） 包含多个 *子域（支撑域）* 其中子域有分类城 核心（定制）-核心竞争力  支撑（比如分销，订单这种可以外包出去的） 通用域（比如用户，登录，支付这种可以在网上找别人代码中用的）

比如订单 产品 发票 物流 是一个上下文（场景）   用户购买产品 支付  
比如 销售（限界上下文） 中  包含 产品子域 订单子域 发票子域 物流子域
仓储（库存上下文） 包含 物流子域 库存子域 以及外部的预测系统（预测库存要存多少）中的某些域
<!-- 用户权限系统（上下文）  -->
所以可以按上下文分系统

一个上下文可以包含多个域 并且这个域可以被其他上下文包含
//上下文=》 场景 ，一个流程  一个工程项目
//子域=》  模块
//=》上下文会互相集成 称之为上下文映射   比如    下单的上游是查询商品 
//一个请求会涉及多个模块或者单个
//顾客子域中
//顾客查询产品  =》 购买情况（订单） 依赖于 可买产品 折扣 产品先前购买情况 产品物流方式  （挑选）
//顾客下单产品  =》   名字，寄送地址  订单总价  （确定要买这个产品之后的流程）

//画图 知服
定制 智能识别 物流 用户 订单 ｜ 电商
通常，我们希望将子域一对一地对应到限界上下文。   销售模块  调用其他模块。。
 身 份 与 访 问 上下 
比如销售域下  零售商向买家展示不同类别的产品允许下单付款 以及物流 库存 发票
上下文映射图 => 服务（上下文）依赖方向  

一个限界上下文就是一个项目 一个jar包？  希望能对应到子域？  一一对应  
upms 一个身份和访问上下文系统   而不是用户系统 权限系统 这根据业务来的。

//获取一个资源要判断权限
不是在这个资源里  获得当前用户和当前用户的权限 然后做判断 ，而是通过身份和访问管理系统 （auth） auth颁发token， 然后认证

一个子域拥有一个上下文 -边界一致
一个子域拥有多个上下文
 限界上下文本质上就是子域
限界上下文的划分体现的是一种更为详细的设计过程
一个上下文系统中 有多个聚合
销售系统中  以订单为主-> 则可以引入user实体


什么是聚合
一个采购申请 采购子项   审批人 申请人
应该是相同生命周期才会有聚合
采购申请（聚合根）包含了采购子项（实体）
审批人和申请人在聚合中只作为一个属性ID
聚合设计应该尽量小

一个系统中可以有多个聚合

可以展开说说了。

在微服务中落地DDD

一个上下文一个子域 是一个微服务
微服务下有多个聚合
比如CMS服务下
有upms权限系统中有  user role permission 等  这种情况就没聚合了。。
如订单系统中   有订单项，订单子项  都有id , 这种情况据昂 order会聚合orderitem order就是 

其实冥冥之中已经实现了DDD了。。 就是引入一个 上下文 最好是通过引入包 或者 http调用的方式实现 。
比如我现在遇到的权限问题，我把handler写在每一个引入的上下文里 这样是不对的，得想想怎么解决


用户身份访问系统
认证用户身份（通过用户密码）颁发登录凭证
凭借这个登录凭借访问其他上下文又不经过

就得把接口抽象成resource 这个会损耗性能很多

1.鉴权网关 所有接口都走这个
 解析token获取用户信息
 用户 查看用户角色 资源
 系统中的资源都注册到 数据库里
 如果是http访问资源 则从系统中访问这个资源信息， 判断这个资源是否需要鉴权 如果不需要直接放过  如果需要 对比用户权限和资源权限是否符合 
 1.网关变成了流量焦点
 2.每次查询网关中负责解析token并，去查询数据信息（或redis） 这个都可以优化从redis中取 否则才找d
 3.资源节点都得依次添加到数据库

优点
1.这个系统可以独立售卖了 符合DDD

//依赖于身份认证系统 所有系统都用同一套用户体系
//id role dept 这些通用的
admin ->user     这些业务相关则自己写
custoemr ->user
merchant ->user
骑手 -> user      

 
如果按我这种做法
1.授权中心负责颁发用户凭证
2.每个服务都是独立鉴权并获取用户信息
3.服务间调用都要多一层token
4.不用把资源节点都注册到服务器 服务内拦截器判断即可
-------------------
好处
不用添加资源节点
多种用户类型比较方便

坏处
每个服务都耦合的鉴权上下文，服务间调用都要传递token 并解析用户信息
不用走api网关 对网关压力小
不符合DDD 除非 





身份和访问上下文 身份不代表用户具体信息 -》通知服务
业务服务 -》通知服务 ， 如果这时候 身份和访问上下文是购买的通用域
商家端登录  则发送时 通知服务 去向 身份和验证上下文 验证有没有 登录凭证为...且moduleid为的merchant的用户，如果有返回成功，然后让验证码上下文//TODO

//比如商家注册 提交一大堆资料，审核通过后 =》在身份和访问上下文 生成模块用户关联
//比如棋手登录验证码 在骑手服务 获取身份和访问上下文是否有棋手服务的手机号（user.hasMobile） ，如果有则调用短信服务去发送。  并生成一条用户临时登录凭证 （mobile,code）（有过期功能） 登录完删除该凭证，或者过期 
//棋手登录输入手机号和验证码，直接调用身份中心用户登录 ，  返回token和信息
//棋手登录 直接调用身份和访问上下文的 登录接口 返回token和权限信息 ，拿这这个就可以访问模块功能
大概如此设计

身份表 id module_id role_id group_id


登录凭证 userid username/mobile password 
        userid mobile/verifycode

模块id关联表 (module_id, user_id,relation_id)        
发送验证码   
